<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SolPlace - Pixel Art on Solana</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            height: 100vh;
        }
        
        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            background: #000;
            position: relative;
        }
        
        #canvas {
            cursor: crosshair;
            image-rendering: pixelated;
            border: 2px solid #333;
            border-radius: 8px;
            transition: transform 0.1s ease;
            background-color: #ffffff !important;
        }
        
        #sidebar {
            width: 420px;
            background: rgba(20, 20, 20, 0.95);
            border-left: 1px solid #333;
            padding: 32px;
            display: flex;
            flex-direction: column;
            gap: 24px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow-y: auto;
        }
        
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }
        
        .logo-container {
            flex-grow: 1;
        }
        
        .twitter-link {
            font-size: 20px;
            font-weight: bold;
            text-decoration: none;
            color: #999;
            margin-left: 10px;
            transition: color 0.2s ease;
            margin-top: 5px;
        }
        
        .twitter-link:hover {
            color: #1DA1F2;
        }
        
        .logo {
            font-size: 32px;
            font-weight: 700;
            background: linear-gradient(45deg, #00FFA3, #03E1FF, #DC1FFF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }
        
        .card {
            background: rgba(30, 30, 30, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(5px);
        }
        
        .card-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #00FFA3;
        }
        
        button {
            padding: 14px 24px;
            background: linear-gradient(45deg, #00FFA3, #03E1FF);
            border: none;
            border-radius: 8px;
            color: #ffffff !important;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            width: 100%;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 163, 0.3);
        }
        
        button:disabled {
            background: rgba(100, 100, 100, 0.5);
            transform: none;
            box-shadow: none;
            cursor: not-allowed;
            color: #888 !important;
        }
        
        .footer-buttons {
            margin-top: auto;
            padding-top: 16px;
            width: 100%;
        }
        
        #how-it-works-btn, #contract-address-btn {
            background: linear-gradient(45deg, #DC1FFF, #03E1FF);
            color: #ffffff !important;
            padding: 10px 24px;
            font-size: 13px;
            margin-bottom: 6px;
        }
        
        #wallet-info {
            font-size: 14px;
            color: #888;
            font-family: monospace;
        }
        
        #color-picker {
            width: 100%;
            height: 48px;
            padding: 0;
            border: 2px solid #00FFA3;
            border-radius: 8px;
            background-color: transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        #color-picker:hover {
            box-shadow: 0 0 12px rgba(0, 255, 163, 0.3);
        }
        
        #status-message {
            padding: 12px;
            border-radius: 8px;
            background: rgba(40, 40, 40, 0.8);
            text-align: center;
            font-size: 14px;
            color: #888;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .gradient-text {
            background: linear-gradient(45deg, #00FFA3, #DC1FFF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 600;
        }
        
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .stat-card {
            background: rgba(40, 40, 40, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: #00FFA3;
            word-break: break-all;
        }
        
        .stat-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .burn-stats {
            background: rgba(30, 30, 30, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-bottom: 16px;
        }
        
        .burn-value {
            font-size: 24px;
            font-weight: 700;
            color: #FF4444;
            margin-bottom: 8px;
        }
        
        .burn-label {
            font-size: 14px;
            color: #888;
        }
        
        .connected-indicator {
            width: 8px;
            height: 8px;
            background: #00FFA3;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .copy-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #00FFA3;
            color: #000;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }
        
        .copy-notification.show {
            opacity: 1;
        }
        
        /* Updated Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            padding: 20px;
            border: 1px solid #333;
            border-radius: 16px;
            width: 80%;
            max-width: 800px;
            position: relative;
            animation: modalFadeIn 0.3s ease;
            overflow: visible; /* Remove scrolling */
            max-height: none; /* Remove height restriction */
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .close {
            color: #888;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .close:hover {
            color: #00FFA3;
        }
        
        .modal h2 {
            color: #00FFA3;
            margin-bottom: 16px;
            font-size: 24px; /* Smaller heading */
        }
        
        .modal h3 {
            color: #03E1FF;
            margin-top: 16px;
            margin-bottom: 8px;
            font-size: 18px; /* Smaller subheading */
        }
        
        .modal p, .modal li {
            color: #888;
            line-height: 1.4;
            margin-bottom: 10px;
            font-size: 14px; /* Smaller text */
        }
        
        .modal ul {
            padding-left: 16px;
            margin-bottom: 12px;
        }
        
        .modal li {
            margin-bottom: 6px;
        }
        
        .feature-list {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr; /* 4 columns instead of 2 */
            gap: 10px;
            margin-top: 16px;
        }
        
        .feature-item {
            background: rgba(40, 40, 40, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
        }
        
        .feature-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        .feature-item h4 {
            font-size: 14px;
            margin-bottom: 4px;
            color: #00FFA3;
        }
        
        .feature-item p {
            font-size: 12px;
            margin-bottom: 0;
        }
        
        @media (max-width: 768px) {
            .modal-content {
                width: 90%;
                padding: 16px;
            }
            
            .feature-list {
                grid-template-columns: 1fr 1fr; /* 2 columns on mobile */
            }
            
            .modal h2 {
                font-size: 20px;
            }
            
            .modal h3 {
                font-size: 16px;
            }
            
            #container {
                flex-direction: column;
            }
            
            #sidebar {
                width: 100%;
                max-height: 300px;
            }
            
            #canvas-container {
                height: calc(100vh - 300px);
            }
        }

        /* Tooltip styles */
        .pixel-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid rgba(0, 255, 163, 0.3);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            max-width: 250px;
        }
        
        .wallet-link {
            color: #00FFA3;
            text-decoration: none;
        }
        
        .wallet-link:hover {
            text-decoration: underline;
        }
        
        .timestamp {
            color: #666;
            font-size: 10px;
            margin-top: 4px;
        }
        
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: #111;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas" width="500" height="500" onclick="canvasClick(event)"></canvas>
        </div>
        <div id="sidebar">
            <div class="header-container">
                <div class="logo-container">
                    <h1 class="logo">SolPlace</h1>
                    <p style="color: #666; font-size: 14px;">Collaborative pixel art on Solana, inspired by r/place.</p>
                </div>
                <a href="https://x.com/SolPlace_io" target="_blank" class="twitter-link" title="Follow us on X/Twitter">ùïè</a>
            </div>
            
            <div class="card">
                <div class="card-title">Wallet Connection</div>
                <button id="connect-wallet" onclick="connectWallet()">Connect Phantom</button>
                <p id="wallet-info" style="margin-top: 12px;">
                    <span class="connected-indicator" style="display: none;"></span>
                    <span id="wallet-address">Not connected</span>
                </p>
            </div>
            
            <div class="card">
                <div class="card-title">Color Selection</div>
                <input type="color" id="color-picker" value="#ff0000">
            </div>
            
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="balance">0</div>
                    <div class="stat-label">$PLACE Balance</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">100</div>
                    <div class="stat-label">Cost per Pixel</div>
                </div>
            </div>
            
            <div class="burn-stats">
                <div class="burn-value" id="burned-amount">0</div>
                <div class="burn-label">$PLACE Burned Total</div>
            </div>
            
            <button id="place-pixel" onclick="placePixel()" disabled>Place Pixel</button>
            
            <div id="status-message">Connect your wallet to start</div>
            
            <div class="footer-buttons">
                <button id="contract-address-btn" onclick="copyContractAddress()">Copy $PLACE CA</button>
                <button id="how-it-works-btn" onclick="showHowItWorks()">How It Works</button>
            </div>
        </div>
    </div>
    
    <div class="copy-notification" id="copy-notification">Contract address copied!</div>
    
    <!-- Tooltip for pixel hover info -->
    <div id="pixel-tooltip" class="pixel-tooltip" style="display: none;"></div>
    
    <!-- Updated modal with new layout -->
    <div id="how-it-works-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>How SolPlace Works</h2>
            
            <h3>Getting Started</h3>
            <p>SolPlace is a collaborative pixel art canvas on Solana where creativity meets blockchain technology.</p>
            
            <ul>
                <li>Connect your Phantom wallet</li>
                <li>Ensure you have $PLACE tokens</li>
                <li>Click any pixel on the canvas</li>
                <li>Select your desired color</li>
                <li>Pay 100 $PLACE to place your pixel</li>
            </ul>
            
            <h3>Features</h3>
            <div class="feature-list">
                <div class="feature-item">
                    <div class="feature-icon">üé®</div>
                    <h4>Unlimited Colors</h4>
                    <p>Choose any color</p>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">‚ö°</div>
                    <h4>Real-time Updates</h4>
                    <p>See changes instantly</p>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">üî•</div>
                    <h4>Token Burning</h4>
                    <p>$PLACE deflationary</p>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">üåê</div>
                    <h4>Permanent Canvas</h4>
                    <p>Art lives forever</p>
                </div>
            </div>
            
            <h3>Deflationary Mechanism</h3>
            <p>Every pixel placement burns 100 $PLACE tokens, removing them from circulation and increasing scarcity over time.</p>
            
            <h3>Dev Allocation</h3>
            <p>The development team holds 2% of the token supply, which is locked for 3 months and then vested over a period of 1 year. These funds will be used to cover server costs, scaling infrastructure, and future feature development.</p>
            
            <h3>Tips</h3>
            <ul>
                <li>Use scroll to zoom in/out on the canvas</li>
                <li>Collaborate with others to create art</li>
                <li>Check your $PLACE balance before placing multiple pixels</li>
                <li>Be creative and respectful of others' work</li>
            </ul>
        </div>
    </div>

    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    
    <script>
        // Global variables
        const API_URL = 'https://place-clone-backend.onrender.com';
        const WS_URL = 'wss://place-clone-backend.onrender.com';
        
        const SPLACE_TOKEN = '38KWMyCbPurCgqqwx5JG4EouREtjwcCaDqvL9KNGsvDf';
        const BURN_ADDRESS = '1nc1nerator11111111111111111111111111111111';
        const COST_PER_PIXEL = 100; // Updated from 10000 to 100
        const TOKEN_DECIMALS = 6;
        
        // Use your paid QuickNode RPC endpoint
        const RPC_ENDPOINT = 'https://radial-chaotic-pool.solana-mainnet.quiknode.pro/192e8e76f0a288f5a32ace0b676f7f34778f219f/';
        
        const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
        const ASSOCIATED_TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
        
        let selectedPixel = null;
        let walletAddress = null;
        let ws = null;
        let connection = null;
        let currentScale = 1;
        let pixelState = {};
        let totalBurned = 0;
        
        // DOM elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('color-picker');
        const connectWalletBtn = document.getElementById('connect-wallet');
        const placePixelBtn = document.getElementById('place-pixel');
        const statusMessage = document.getElementById('status-message');
        const walletAddressSpan = document.getElementById('wallet-address');
        const balanceSpan = document.getElementById('balance');
        const burnedAmountSpan = document.getElementById('burned-amount');
        const connectedIndicator = document.querySelector('.connected-indicator');
        const modal = document.getElementById('how-it-works-modal');
        const copyNotification = document.getElementById('copy-notification');
        const pixelTooltip = document.getElementById('pixel-tooltip');
        
        // Initialize canvas
        function initCanvas() {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Initialize WebSocket
        function initWebSocket() {
            try {
                console.log('Connecting to WebSocket server...');
                ws = new WebSocket(WS_URL);
                
                ws.onopen = () => {
                    console.log('WebSocket connected');
                    updateStatus('Connected to server');
                    
                    // Request the full canvas state
                    ws.send(JSON.stringify({ 
                        type: 'get_canvas_state',
                        client: walletAddress || 'anonymous_' + Math.random().toString(36).substring(2, 10)
                    }));
                };
                
                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        if (data.type === 'canvas_state') {
                            console.log('Canvas state received');
                            pixelState = data.pixels || {};
                            updateCanvasState(pixelState);
                            totalBurned = data.totalBurned || 0;
                            updateBurnedDisplay();
                        } else if (data.type === 'pixel_update') {
                            console.log('Pixel update received:', data.x, data.y, data.color);
                            
                            // Store full pixel data
                            pixelState[`${data.x},${data.y}`] = {
                                color: data.color,
                                wallet: data.walletAddress,
                                timestamp: data.timestamp
                            };
                            
                            updatePixel(data.x, data.y, data.color);
                            
                            // Always update burn counter by 100 tokens for every pixel placement
                            // This ensures it increments for all pixel placements
                            totalBurned += COST_PER_PIXEL;
                            updateBurnedDisplay();
                        }
                    } catch (error) {
                        console.error('Error processing message:', error);
                    }
                };
                
                ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    updateStatus('Connection lost. Reconnecting...');
                    setTimeout(initWebSocket, 3000);
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('Connection error. Retrying...');
                };
            } catch (error) {
                console.error('Error creating WebSocket:', error);
                setTimeout(initWebSocket, 3000);
            }
        }
        
        // Initialize connection to Solana with the QuickNode RPC
        async function initConnection() {
            try {
                console.log('Connecting to Solana RPC:', RPC_ENDPOINT);
                connection = new solanaWeb3.Connection(RPC_ENDPOINT, {
                    commitment: 'confirmed',
                    confirmTransactionInitialTimeout: 60000,
                    disableRetryOnRateLimit: false
                });
                
                // Test the connection
                const version = await connection.getVersion();
                console.log('Connected to Solana RPC, version:', version);
                
                return true;
            } catch (error) {
                console.error('RPC connection error:', error);
                
                // Fallback to public endpoint
                try {
                    const fallbackEndpoint = 'https://api.mainnet-beta.solana.com';
                    console.log('Falling back to public endpoint:', fallbackEndpoint);
                    connection = new solanaWeb3.Connection(fallbackEndpoint, 'confirmed');
                    
                    return true;
                } catch (fallbackError) {
                    console.error('Fallback RPC error:', fallbackError);
                    return false;
                }
            }
        }
        
        // Utility function to retry operations on errors
        async function withRetry(fn, maxRetries = 3) {
            let retries = 0;
            let lastError = null;
            
            while (retries < maxRetries) {
                try {
                    return await fn();
                } catch (error) {
                    lastError = error;
                    retries++;
                    console.log(`Operation failed, retry ${retries}/${maxRetries}:`, error.message);
                    
                    // Exponential backoff
                    if (retries < maxRetries) {
                        const delay = Math.min(1000 * Math.pow(2, retries), 10000);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }
            
            throw lastError;
        }
        
        // Canvas state functions with wallet info
        function updateCanvasState(pixels) {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            Object.entries(pixels).forEach(([key, data]) => {
                const [x, y] = key.split(',').map(Number);
                
                // Handle both string (legacy) and object formats
                const color = typeof data === 'string' ? data : data.color;
                
                if (color && color !== '#ffffff') {
                    ctx.fillStyle = color;
                    ctx.fillRect(x * 5, y * 5, 5, 5);
                }
            });
            
            if (selectedPixel) {
                highlightPixel(selectedPixel.x, selectedPixel.y);
            }
        }
        
        function updatePixel(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * 5, y * 5, 5, 5);
            
            if (selectedPixel && selectedPixel.x === x && selectedPixel.y === y) {
                highlightPixel(x, y);
            }
        }
        
        function highlightPixel(x, y) {
            ctx.strokeStyle = '#00FFA3';
            ctx.lineWidth = 2;
            ctx.strokeRect(x * 5, y * 5, 5, 5);
        }
        
        // Hover tooltip functions
        function showTooltip(x, y, pixelData) {
            if (!pixelData || typeof pixelData === 'string' || !pixelData.wallet) {
                hideTooltip();
                return;
            }
            
            const wallet = pixelData.wallet;
            const timestamp = pixelData.timestamp ? new Date(pixelData.timestamp).toLocaleString() : 'Unknown date';
            const shortWallet = wallet.slice(0, 6) + '...' + wallet.slice(-4);
            
            pixelTooltip.innerHTML = `
                <div>Placed by: <a href="https://solscan.io/account/${wallet}" target="_blank" class="wallet-link">${shortWallet}</a></div>
                <div class="timestamp">${timestamp}</div>
            `;
            
            pixelTooltip.style.display = 'block';
            pixelTooltip.style.left = `${x}px`;
            pixelTooltip.style.top = `${y}px`;
        }
        
        function hideTooltip() {
            pixelTooltip.style.display = 'none';
        }
        
        // Utility functions
        function formatBalance(num) {
            const actualValue = num / Math.pow(10, TOKEN_DECIMALS);
            if (actualValue < 1000) return actualValue.toString();
            if (actualValue < 1000000) {
                const k = actualValue / 1000;
                return k % 1 === 0 ? k + 'K' : k.toFixed(1) + 'K';
            }
            const m = actualValue / 1000000;
            return m % 1 === 0 ? m + 'M' : m.toFixed(1) + 'M';
        }
        
        function formatBurnCount(num) {
            if (num < 1000) return num.toString();
            if (num < 1000000) {
                const k = num / 1000;
                return k % 1 === 0 ? k + 'K' : k.toFixed(1) + 'K';
            }
            const m = num / 1000000;
            return m % 1 === 0 ? m + 'M' : m.toFixed(1) + 'M';
        }
        
        function updateStatus(message) {
            statusMessage.textContent = message;
        }
        
        function updateBurnedDisplay() {
            burnedAmountSpan.textContent = formatBurnCount(totalBurned);
        }
        
        // Event handlers
        function canvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / currentScale / 5);
            const y = Math.floor((e.clientY - rect.top) / currentScale / 5);
            
            if (x >= 0 && x < 100 && y >= 0 && y < 100) {
                selectedPixel = { x, y };
                updateCanvasState(pixelState);
                updateStatus(`Selected pixel: (${x}, ${y})`);
            }
        }
        
        // Canvas hover event for tooltip
        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / currentScale / 5);
            const y = Math.floor((e.clientY - rect.top) / currentScale / 5);
            
            if (x >= 0 && x < 100 && y >= 0 && y < 100) {
                const pixelKey = `${x},${y}`;
                const pixelData = pixelState[pixelKey];
                
                if (pixelData && (pixelData.wallet || (typeof pixelData !== 'string' && pixelData.color !== '#ffffff'))) {
                    showTooltip(e.clientX + 10, e.clientY + 10, pixelData);
                } else {
                    hideTooltip();
                }
            } else {
                hideTooltip();
            }
        });
        
        canvas.addEventListener('mouseout', hideTooltip);
        
        // Add zoom functionality
        document.getElementById('canvas-container').addEventListener('wheel', function(e) {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            currentScale = Math.max(0.5, Math.min(5, currentScale * delta));
            
            canvas.style.transform = `scale(${currentScale})`;
        });
        
        function connectWallet() {
            try {
                const { solana } = window;
                if (!solana || !solana.isPhantom) {
                    alert('Phantom wallet not installed!');
                    return;
                }
                
                updateStatus('Connecting to wallet...');
                
                solana.connect()
                    .then(response => {
                        walletAddress = response.publicKey.toString();
                        walletAddressSpan.textContent = `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;
                        connectWalletBtn.textContent = 'Connected';
                        connectWalletBtn.disabled = true;
                        connectedIndicator.style.display = 'inline-block';
                        placePixelBtn.disabled = false;
                        updateStatus('Wallet connected!');
                        
                        checkBalance();
                    })
                    .catch(error => {
                        updateStatus(`Error: ${error.message}`);
                    });
            } catch (error) {
                updateStatus(`Error: ${error.message}`);
            }
        }
        
        async function checkBalance() {
            if (!walletAddress) return;
            
            balanceSpan.textContent = 'Loading...';
            try {
                // Always use the correct token address for balance checks
                const PLACE_TOKEN_ADDRESS = new solanaWeb3.PublicKey(SPLACE_TOKEN);
                
                try {
                    // Try using direct RPC call with the specific SPL token address
                    const ownerPubkey = new solanaWeb3.PublicKey(walletAddress);
                    
                    const associatedTokenAddress = await getAssociatedTokenAddress(
                        PLACE_TOKEN_ADDRESS,
                        ownerPubkey
                    );
                    
                    const accountInfo = await connection.getAccountInfo(associatedTokenAddress);
                    
                    if (accountInfo) {
                        const data = accountInfo.data;
                        // Get amount from SPL token account data structure (at offset 64)
                        const dataView = new DataView(data.buffer, 64, 8);
                        const amount = dataView.getBigUint64(0, true);
                        
                        // Format balance to display the actual token amount (accounting for decimals)
                        const actualAmount = Number(amount) / Math.pow(10, TOKEN_DECIMALS);
                        balanceSpan.textContent = formatBalance(Number(amount));
                        console.log(`Wallet has ${actualAmount} $PLACE tokens`);
                    } else {
                        balanceSpan.textContent = '0';
                    }
                } catch (directError) {
                    console.error('Direct balance check error:', directError);
                    
                    // Fall back to server-side balance check if direct check fails
                    const response = await fetch(`${API_URL}/balance/${walletAddress}`);
                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    balanceSpan.textContent = formatBalance(data.formatted);
                }
            } catch (error) {
                console.error('Balance check error:', error);
                balanceSpan.textContent = '0';
            }
        }
        
        async function getAssociatedTokenAddress(mint, owner) {
            try {
                const [address] = await solanaWeb3.PublicKey.findProgramAddress(
                    [
                        owner.toBuffer(),
                        TOKEN_PROGRAM_ID.toBuffer(),
                        mint.toBuffer(),
                    ],
                    ASSOCIATED_TOKEN_PROGRAM_ID
                );
                return address;
            } catch (error) {
                console.error('Error getting associated token address:', error);
                throw error;
            }
        }
        
        function createTokenTransferInstruction(fromTokenAccount, toTokenAccount, owner, amount) {
            const data = new Uint8Array(9);
            data[0] = 3; // Transfer instruction
            const view = new DataView(data.buffer);
            view.setBigUint64(1, BigInt(amount), true);
            
            return new solanaWeb3.TransactionInstruction({
                keys: [
                    { pubkey: fromTokenAccount, isSigner: false, isWritable: true },
                    { pubkey: toTokenAccount, isSigner: false, isWritable: true },
                    { pubkey: owner, isSigner: true, isWritable: false },
                ],
                programId: TOKEN_PROGRAM_ID,
                data
            });
        }
        
        function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint) {
            const keys = [
                { pubkey: payer, isSigner: true, isWritable: true },
                { pubkey: associatedToken, isSigner: false, isWritable: true },
                { pubkey: owner, isSigner: false, isWritable: false },
                { pubkey: mint, isSigner: false, isWritable: false },
                { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
            ];
            
            return new solanaWeb3.TransactionInstruction({
                keys,
                programId: ASSOCIATED_TOKEN_PROGRAM_ID,
                data: new Uint8Array(0)
            });
        }
        
        // Add Compute Budget Program instructions for optimized fee and compute unit handling
        function addPriorityFeeInstruction(transaction, priorityFee = 10000) {
            const priorityFeeInstruction = solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({
                microLamports: priorityFee
            });
            transaction.add(priorityFeeInstruction);
        }
        
        function addComputeUnitLimitInstruction(transaction, computeUnitsLimit = 200000) {
            const computeUnitLimitInstruction = solanaWeb3.ComputeBudgetProgram.setComputeUnitLimit({
                units: computeUnitsLimit
            });
            transaction.add(computeUnitLimitInstruction);
        }
        
        async function placePixel() {
            if (!selectedPixel || !walletAddress) {
                updateStatus('Please select a pixel and connect wallet');
                return;
            }
            
            updateStatus('Creating transaction...');
            placePixelBtn.disabled = true;
            
            try {
                const color = colorPicker.value;
                const { solana } = window;
                
                // Get the latest blockhash - with retry
                const latestBlockhash = await withRetry(async () => {
                    return await connection.getLatestBlockhash();
                });
                
                const mintPubkey = new solanaWeb3.PublicKey(SPLACE_TOKEN);
                const ownerPubkey = new solanaWeb3.PublicKey(walletAddress);
                const burnPubkey = new solanaWeb3.PublicKey(BURN_ADDRESS);
                
                // Get token accounts - with retry
                const ownerTokenAccount = await withRetry(async () => {
                    return await getAssociatedTokenAddress(mintPubkey, ownerPubkey);
                });
                
                const burnTokenAccount = await withRetry(async () => {
                    return await getAssociatedTokenAddress(mintPubkey, burnPubkey);
                });
                
                // Create a new transaction with priority fee and compute limit instructions
                const transaction = new solanaWeb3.Transaction();
                
                // Add priority fee and compute unit limit instructions
                addPriorityFeeInstruction(transaction, 50000); // Higher priority fee
                addComputeUnitLimitInstruction(transaction, 200000);
                
                // Check if burn account exists and create it if needed
                let burnAccountExists = false;
                try {
                    const burnAccountInfo = await connection.getAccountInfo(burnTokenAccount);
                    burnAccountExists = !!burnAccountInfo;
                } catch (error) {
                    console.log('Error checking burn account:', error.message);
                }
                
                if (!burnAccountExists) {
                    console.log('Burn account does not exist, adding creation instruction');
                    const createAccountInstruction = createAssociatedTokenAccountInstruction(
                        ownerPubkey,
                        burnTokenAccount,
                        burnPubkey,
                        mintPubkey
                    );
                    transaction.add(createAccountInstruction);
                }
                
                // Create token transfer instruction
                const amount = COST_PER_PIXEL * Math.pow(10, TOKEN_DECIMALS);
                const transferInstruction = createTokenTransferInstruction(
                    ownerTokenAccount,
                    burnTokenAccount,
                    ownerPubkey,
                    amount
                );
                
                transaction.add(transferInstruction);
                transaction.recentBlockhash = latestBlockhash.blockhash;
                transaction.feePayer = ownerPubkey;
                
                updateStatus('Waiting for wallet approval...');
                
                // Sign and send the transaction
                const signResult = await solana.signAndSendTransaction(transaction);
                const signature = signResult.signature;
                console.log('Transaction signature:', signature);
                
                // Optimistically update the UI immediately
                const timestamp = Date.now();
                
                // Update in-memory state first
                pixelState[`${selectedPixel.x},${selectedPixel.y}`] = {
                    color: color,
                    wallet: walletAddress,
                    timestamp: timestamp
                };
                
                // Update visual display
                updatePixel(selectedPixel.x, selectedPixel.y, color);
                
                // Increment the burn counter by 100 tokens each time a pixel is placed
                totalBurned += COST_PER_PIXEL;
                updateBurnedDisplay();
                
                updateStatus('Pixel placed! Syncing with server...');
                
                // Send via WebSocket for real-time updates to other clients
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'pixel_update',
                        x: selectedPixel.x,
                        y: selectedPixel.y,
                        color: color,
                        walletAddress: walletAddress,
                        signature: signature,
                        timestamp: timestamp,
                        self: true // Flag to prevent double-counting
                    }));
                }
                
                // Prepare pixel data for server
                const pixelData = {
                    x: selectedPixel.x,
                    y: selectedPixel.y,
                    color: color,
                    walletAddress: walletAddress,
                    signature: signature,
                    burnAddress: BURN_ADDRESS,
                    tokenMint: SPLACE_TOKEN,
                    tokenAmount: amount.toString(),
                    timestamp: timestamp
                };
                
                // Send HTTP request with retry - updated version with better error handling
                let serverSynced = false;
                let lastErrorMessage = null;

                for (let attempt = 1; attempt <= 5; attempt++) { // Increased to 5 attempts
                    try {
                        console.log(`Server sync attempt ${attempt}/5`);
                        
                        const response = await fetch(`${API_URL}/place-pixel`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(pixelData)
                        });
                        
                        // Handle non-200 status codes
                        if (!response.ok) {
                            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                        }
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            console.log('Pixel placement confirmed by server');
                            updateStatus('Pixel placed successfully!');
                            serverSynced = true;
                            
                            // Check balance after successful placement to update UI
                            checkBalance();
                            
                            // Refresh canvas state to ensure everything is in sync
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                setTimeout(() => {
                                    ws.send(JSON.stringify({
                                        type: 'get_canvas_state',
                                        client: walletAddress
                                    }));
                                }, 2000);
                            }
                            
                            break; // Successfully synced, exit retry loop
                        } else {
                            // Server returned success: false with an error message
                            lastErrorMessage = data.error || 'Unknown server error';
                            console.error('Server error:', lastErrorMessage);
                            
                            // Use longer delays for later attempts
                            if (attempt < 5) {
                                const retryDelay = Math.min(1000 * Math.pow(2, attempt - 1), 15000);
                                console.log(`Retrying server sync in ${retryDelay}ms (attempt ${attempt}/5)`);
                                updateStatus(`Server sync failed. Retrying in ${retryDelay/1000}s...`);
                                await new Promise(resolve => setTimeout(resolve, retryDelay));
                            }
                        }
                    } catch (fetchError) {
                        lastErrorMessage = fetchError.message;
                        console.error(`HTTP error (attempt ${attempt}/5):`, fetchError);
                        
                        if (attempt < 5) {
                            const retryDelay = Math.min(1000 * Math.pow(2, attempt - 1), 15000);
                            console.log(`Retrying server sync in ${retryDelay}ms`);
                            updateStatus(`Server connection error. Retrying in ${retryDelay/1000}s...`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                        }
                    }
                }

                // Special manual recovery attempt if all auto-retries failed
                if (!serverSynced) {
                    updateStatus(`Server sync failed: ${lastErrorMessage || 'Unknown error'}. Attempting recovery...`);
                    
                    try {
                        // Wait a bit longer (10s) and try one last time with a different approach
                        await new Promise(resolve => setTimeout(resolve, 10000));
                        
                        // Try a different endpoint variation - sometimes this can help with caching issues
                        const finalAttemptUrl = `${API_URL}/place-pixel?t=${Date.now()}`;
                        const response = await fetch(finalAttemptUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Cache-Control': 'no-cache',
                                'Pragma': 'no-cache'
                            },
                            body: JSON.stringify({
                                ...pixelData,
                                timestamp: Date.now() // Update timestamp
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            console.log('Recovery attempt succeeded!');
                            updateStatus('Pixel placed successfully!');
                            serverSynced = true;
                            
                            // Check balance again
                            checkBalance();
                        } else {
                            throw new Error(data.error || 'Recovery failed');
                        }
                    } catch (recoveryError) {
                        console.error('Recovery attempt failed:', recoveryError);
                        updateStatus('Warning: Transaction confirmed but server sync failed. The pixel may not persist.');
                    }
                }
                
            } catch (error) {
                console.error('Transaction error:', error);
                updateStatus(`Error: ${error.message}`);
            } finally {
                placePixelBtn.disabled = false;
            }
        }
        
        function showHowItWorks() {
            modal.style.display = 'flex'; // Changed from 'block' to 'flex' for centering
        }
        
        function closeModal() {
            modal.style.display = 'none';
        }
        
        function copyContractAddress() {
            navigator.clipboard.writeText(SPLACE_TOKEN).then(() => {
                copyNotification.classList.add('show');
                setTimeout(() => {
                    copyNotification.classList.remove('show');
                }, 2000);
            });
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        };
        
        // Initialize the app with better error handling
        async function initApp() {
            console.log('Initializing SolPlace app...');
            
            initCanvas();
            
            // Connect to RPC with retries if needed
            let connected = false;
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    connected = await initConnection();
                    if (connected) {
                        console.log('RPC connected successfully');
                        break;
                    }
                } catch (error) {
                    console.error(`RPC connection error (attempt ${attempt}/3):`, error);
                    if (attempt < 3) {
                        console.log(`Retrying connection in ${attempt * 1000}ms...`);
                        await new Promise(resolve => setTimeout(resolve, attempt * 1000));
                    }
                }
            }
            
            if (!connected) {
                updateStatus('Error connecting to Solana. Please refresh.');
                return;
            }
            
            // Initialize WebSocket connection
            initWebSocket();
            updateStatus('Connect your wallet to start');
        }
        
        // Start the app when document is ready
        document.addEventListener('DOMContentLoaded', function() {
            initApp();
        });
    </script>
</body>
</html>
